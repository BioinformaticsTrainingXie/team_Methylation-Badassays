---
title: "PreprocessQC_MY"
author: "Michael Yuen"
date: "March 10, 2017"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We are following this [Minfi tutorial](https://www.bioconductor.org/help/course-materials/2015/BioC2015/methylation450k.html).

And we used some additional Minfi functions for QC following the advice of helpful grad students (Thanks Robinson lab!) and [Dr. Meaghan's STAT540 DNA methylation lecture](https://stat540-ubc.github.io/subpages/lectures.html)

For general information on Minfi, consult the [user guide](http://bioconductor.org/packages/release/bioc/vignettes/minfi/inst/doc/minfi.pdf)

Further info about the functions and capabilities of Minfi can be found in the [Minfi reference manual](http://bioconductor.org/packages/release/bioc/manuals/minfi/man/minfi.pdf)

For the relevant paper with more comprehensive discussion of Minfi check out this [paper](https://academic.oup.com/bioinformatics/article/30/10/1363/267584/Minfi-a-flexible-and-comprehensive-Bioconductor)



```{r, load libraries, message=FALSE}
library(minfi)
library(dplyr)
library(ggplot2)
```
#1.0 Introduction

Minfi has a couple of different classes because...

The following classes and their details:

RGChannelSet - Raw intensities 
MethylSet - 
GenomicMethylSet
RatioSet
GenomicRatioSet

different classes allow for ' a flexible framework for method development and analyses'
The natural starting point for analysis is usually the GenomicRatioSet class.

#1.1 Load data
```{r, read data}
#input the right base directory
getwd() #input the right base directory
setwd("./data/Raw Data/")
basedir <- getwd()
samplesheet <- read.metharray.sheet(basedir, recursive = TRUE) # read in sample sheet .csv file
Eth_rgset <- read.metharray.exp(targets = samplesheet) # read in iDAT files using sample sheet
```


```{r}
pheno <- pData(Eth_rgset) # phenotype data (from sample sheet)
pheno[,1:6]
mani <- getManifest(Eth_rgset) # manifest probe design information
```

Comparing preprocessing methodology
```{r}
MSet.raw <- preprocessRaw(Eth_rgset)
MSet.raw <- MSet.raw[order(featureNames(MSet.raw)), ]

MSet.noob <- preprocessNoob(Eth_rgset)
MSet.noob <- MSet.noob[order(featureNames(MSet.noob)), ]

eth_preproc_funnorm <- preprocessFunnorm(Eth_rgset, nPCs = 2, sex = NULL, bgCorr = TRUE, dyeCorr = TRUE, verbose = TRUE)
eth_preproc_funnorm <- eth_preproc_funnorm[order(featureNames(eth_preproc_funnorm)), ]

eth_preproc_quant <- preprocessQuantile(Eth_rgset, fixOutliers = TRUE, removeBadSamples = FALSE, quantileNormalize = TRUE, stratified = TRUE, mergeManifest = FALSE, sex = NULL)
eth_preproc_quant <- eth_preproc_quant[order(featureNames(eth_preproc_quant)),]

## later on we can use getSex() on preprocessed data to double check genders for each observation
    
probeTypes <- data.frame(Name = featureNames(MSet.raw),
                         Type = getProbeType(MSet.raw))

#legendpos = "btm" is used to generate an error to remove the legend all together. 
plotBetasByType(MSet.raw[,1], main = "Raw")
plotBetasByType(MSet.noob[,1], main = "Noob")
plotBetasByType(getBeta(eth_preproc_funnorm[,1]), probeTypes = probeTypes, main = "funNorm_noob")
plotBetasByType(getBeta(eth_preproc_quant[,1]), probeTypes = probeTypes, main = "Quantile")
```

> A good preprocessing method should make the peaks of type 1 & 2 probe distributions close together, so functional normalization appears to be better. PreprocessingFunnorm is best.

#1.2 Create Classes (no longer needed in preprocessFunnorm)
Generating MethylSet and RatioSet for preprocessing raw and preprocessing noob
```{r}
#MSet.raw <- preprocessRaw(Eth_rgset)
#MSet.noob <- preprocessNoob(Eth_rgset)
```

Get GenomicRatioSet
```{r}
#GRset <- mapToGenome(RSet)# Various functions available to access GRSet data
#gr <- granges(GRset)
```

#2. QC
--------------------------------------------------------------------------------------------------------------------------------------------
Note: I think we should move all of the QC to here, so that it is obvious that we do QC before normalization -victor
Note: I'm just going to move your section over here Ming, -Victor
--------------------------------------------------------------------------------------------------------------------------------------------

```{r}
qc <- getQC(MSet.raw)
plotQC(qc)
```

> The plot estimates samples-specific probe intensities from the MethylSet, comparing methylation probes (M) against unmethylation probes (UM). Intensities for each M and UM are plotted to ensure that they have similar intensities and that the intensities stronger than 10.

```{r}
densityPlot(MSet.raw, sampGroups = pheno$Ethnicity) #bit hard to see
```

> This is a density plot of the beta values for all samples annotated by ethnicity. Beta values are the estimate of methylation level at each position using the ratio of intensities between methylated and unmethylated probes. Beta values are expected to follow a bimodel distribution of roughly 0s and 1s.

```{r}
densityBeanPlot(MSet.raw, sampGroups = pheno$Ethnicity) #This is pretty messy, can we make it look betteR? (split into two graphs maybe?)
```

> Similar to the density plot above, but plotted as a bean plot, color coded by ethnicity

```{r}
controlStripPlot(Eth_rgset, controls="BISULFITE CONVERSION II") #Red is type 1, green is type 2
```

> The 450k array contains several internal control probes that can be used to assess the quality control of different sample preparation steps, in this case, bisulfite conversion. Each control probe is plotted as a strip plot here, showing the consistency of each control probe, suggesting that the changes in our probe sets are not due to errors in preparation.

```{r}
mdsPlot(Eth_rgset, sampNames = pheno$Sample_Name, sampGroups = pheno$Ethnicity)
```

> The Multi-Dimensional Scaling (MDS) plot showss a 2D projection of beta values. The distance between samples show their similarity to each other. It is used as a mean to visually conceptualize the data without making claims to its significance.


* Noob: "Implements the noob background subtraction method with dye-bias normalization"
* Functional Normalization: "This function applies the preprocessNoob function as a first step for background substraction, and uses the first two principal components of the control probes to infer the unwanted variation"
* Quantile Normalization: "Implements stratified quantile normalization preprocessing"

### Sex check
```{r}
eth_preproc_funnorm@colData$sex
predicted_sex <- eth_preproc_funnorm@colData$predictedSex
for (i in 1:length(predicted_sex)){
  if (predicted_sex[i] == "F") {predicted_sex[i] = "FEMALE"}
  else {predicted_sex[i] = "MALE"} }
predicted_sex == eth_preproc_funnorm@colData$sex
## all match
```


### Checking for the presence of SNPs inside the probe body or CpG or at the nucleotide extension
```{r}
# check presence of SNPs inside probe body or single nucleotide extensions
snps <- getSnpInfo(eth_preproc_funnorm)
str(snps@listData$Probe_rs)

eth_preproc_funnorm <- addSnpInfo(eth_preproc_funnorm)
# drop the probes that contain either a SNP at the CpG interrogation or at the single nucleotide extension
eth_preproc_funnorm_rmSNP <- dropLociWithSnps(eth_preproc_funnorm, snps=c("SBE","CpG"), maf=0)
eth_preproc_funnorm_rmSNP
```

