---
title: "PreprocessQC"
author: "Victor, Ming, Michael"
output: 
  html_document: 
    keep_md: yes
    toc: yes
---

We are following this Minfi tutorial:
https://www.bioconductor.org/help/course-materials/2015/BioC2015/methylation450k.html

And we used some additional Minfi functions for QC following the advice of helpful grad students (Thanks Robinson lab!) and [Dr. Meaghan's STAT540 DNA methylation lecture] (http://stat540-ubc.github.io/lectures/lect15_STAT540_Methylation_Presentation%20MJ%20March%202017.pdf)

For general information on Minfi, consult the user guide:
http://bioconductor.org/packages/release/bioc/vignettes/minfi/inst/doc/minfi.pdf

Further info about the functions and capabilities of Minfi can be found in the Minfi reference manual:
http://bioconductor.org/packages/release/bioc/manuals/minfi/man/minfi.pdf

For the relevant paper with more comprehensive discussion of Minfi:
https://academic.oup.com/bioinformatics/article/30/10/1363/267584/Minfi-a-flexible-and-comprehensive-Bioconductor

#1.0 Introduction

Minfi package separates data from annotation and annotation from array design. The annotation means how methylation loci are associated with gneomic locations and design means how probes on the array are matched with relevant color channels to produce the Meth and Unmeth signals. 

Minfi has a couple of different classes to enable flexible development of preprocessing and analysis methods. For the classes have 'Genomic' prefix, it means the methylation loci have been associated with genomic location. The natural starting point for analysis is usually the GenomicRatioSet class.

The following classes and their details:

- **RGChannelSet**: a binary format containing the raw green and red channel intensities.  

- **MethylSet** represents the Meth and Unmeth measurements and are useful for preprocessing routines delivering final measurements in these channels.

- **GenomicMethylSet** represents the Meth and Unmeth measurements and are useful for preprocessing routines delivering final measurements in these channels. Also, the methylation loci have been associated with genomic location.

- **RatioSet** represents the data as beta values (methylation ratios) or M-values (log ratios of beta values).

- **GenomicRatioSet** represents the data as beta values (methylation ratios) or M-values (log ratios of beta values). Also, the methylation loci have been associated with genomic location.

The natural starting point for analysis is usually the GenomicRatioSet class.

#1.1 Dependencies

Installed the necessary dependencies by: 

```{r, load libraries, message=FALSE}
#source("https://bioconductor.org/biocLite.R")
#biocLite("wateRmelon")
#biocLite('limma')
library(wateRmelon)
library(minfi)
library(dplyr)
library(ggplot2)
```

#1.2 Load data

We start with reading the .IDAT files and we read in a sample sheet, and then use the sample sheet to load the data into a RGChannelSet. 

```{r, read data}
#input the right base directory
getwd() #input the right base directory
setwd("./data/Raw Data/")
basedir <- getwd()
samplesheet <- read.metharray.sheet(basedir, recursive = TRUE) # read in sample sheet .csv file
Eth_rgset <- read.metharray.exp(targets = samplesheet) # read in iDAT files using sample sheet
Eth_rgset2 <- read.metharray.exp(targets = samplesheet, extended = TRUE) #extended Rgset to get bead count info
```

The Eth_rgset class contains the intensities of the internal control probes as well and as our data were read from a data sheet experiment, the phenotype data is also stored in the Eth_rgset and can be accessed via the accessor command pData.

```{r, pData}
pheno <- pData(Eth_rgset) # phenotype data (from sample sheet)
pheno[,1:6]
mani <- getManifest(Eth_rgset) # manifest probe design information of the array.
```

#1.3 Create Classes
Generating **MethylSet**, which contains only the methylated and unmethylated signals, and **RatioSet**, which stores Beta vlues and/or M values instead of the methylated and unmethylated signals: 

```{r}
MSet <- preprocessRaw(Eth_rgset) # Mset function matches up the different probes and color channels. 

RSet <- ratioConvert(MSet, what = "both", keepCN = TRUE) #CN is the sum of the methylated and unmethylated signals/

beta <- getBeta(RSet) # The function getBeta returns the Beta value matrix. 
```

Get **GenomicRatioSet**, 

```{r}
GRset <- mapToGenome(RSet) #The function mapToGenome applied to a RatioSet object adds genomic coordinates to each probe together with some additional annotation information.

gr <- granges(GRset) #to return the probe locations as a genomic ranges. 
```

#2. QC
--------------------------------------------------------------------------------------------------------------------------------------------
Note: I think we should move all of the QC to here, so that it is obvious that we do QC before normalization -victor
Note: I'm just going to move your section over here Ming, -Victor
--------------------------------------------------------------------------------------------------------------------------------------------

Samples with lots of bad detection p value probes will appear as outliers in the following QC plots. Bad detection p value probes are basically probes that fail to be statistically different (p value > 0.01) from background intensity. Illumina has a set a of negative control probes that give us the 'background intensity value'.

```{r}
qc <- getQC(MSet)
plotQC(qc)
```
--Talk about above plot here. Good / Bad?

```{r}
densityPlot(MSet, sampGroups = pheno$Ethnicity) #bit hard to see
```
--Talk about above plot

```{r}
densityBeanPlot(MSet, sampGroups = pheno$Ethnicity) #This is pretty messy, can we make it look betteR? (split into two graphs maybe?)
```
--Talka bout plot

```{r}
controlStripPlot(Eth_rgset, controls="BISULFITE CONVERSION II") #Red is type 1, green is type 2
```
-- Talk about above

```{r}
mdsPlot(Eth_rgset, sampNames = pheno$Sample_Name, sampGroups = pheno$Ethnicity)
```

```{r bad detection p values}
bad_p <- detectionP(Eth_rgset, type = "m+u")
MSet2 <- MSet[rowSums(bad_p <= 0.01) == ncol(bad_p),]
```
Went from `r nrow(MSet)` to 'r nrow(MSet2)' Probes

```{r beadcount}
bead <- beadcount(Eth_rgset2)
bead2 <- as.matrix(bead)
#MSet3 <- MSet2[rowSums(!is.na(bead2)) == ncol(bead2),]

bead3 <- as.data.frame(rowSums(!is.na(bead2)) == ncol(bead2))
colnames(bead3) <- 'x'
bead3$cpg <- row.names(bead3)
bead3 <- filter(bead3, x != TRUE)
head(bead3)

MSet2[!row.names(MSet2) %in% bead3$cpg,]

pfilter(Eth_rgset2, pnthresh = 0.01)
```

3. Normalization
Try different normalization:

* Noob: "Implements the noob background subtraction method with dye-bias normalization"
* Functional Normalization: "This function applies the preprocessNoob function as a first step for background substraction, and uses the first two principal components of the control probes to infer the unwanted variation"
* Quantile Normalization: "Implements stratified quantile normalization preprocessing"

### 1.3 Comparing preprocessing methodology
```{r}
MSet.raw <- preprocessRaw(Eth_rgset)
MSet.raw <- MSet.raw[order(featureNames(MSet.raw)), ]

MSet.noob <- preprocessNoob(Eth_rgset)
MSet.noob <- MSet.noob[order(featureNames(MSet.noob)), ]

eth_preproc_funnorm <- preprocessFunnorm(Eth_rgset, nPCs = 2, sex = NULL, bgCorr = TRUE, dyeCorr = TRUE, verbose = TRUE)
eth_preproc_funnorm <- eth_preproc_funnorm[order(featureNames(eth_preproc_funnorm)), ]

eth_preproc_quant <- preprocessQuantile(Eth_rgset, fixOutliers = TRUE, removeBadSamples = FALSE, quantileNormalize = TRUE, stratified = TRUE, mergeManifest = FALSE, sex = NULL)
eth_preproc_quant <- eth_preproc_quant[order(featureNames(eth_preproc_quant)),]

## later on we can use getSex() on preprocessed data to double check genders for each observation
    
probeTypes <- data.frame(Name = featureNames(MSet.raw),
                         Type = getProbeType(MSet.raw))

#legendpos = "btm" is used to generate an error to remove the legend all together. 
plotBetasByType(MSet.raw[,1], main = "Raw")
plotBetasByType(MSet.noob[,1], main = "Noob")
plotBetasByType(getBeta(eth_preproc_funnorm[,1]), probeTypes = probeTypes, main = "funNorm_noob")
plotBetasByType(getBeta(eth_preproc_quant[,1]), probeTypes = probeTypes, main = "Quantile")
```

> A good preprocessing method should make the peaks of type 1 & 2 probe distributions close together, so functional normalization appears to be better at this task with our dataset.

### Sex check
```{r}
eth_preproc_funnorm@colData$sex
predicted_sex <- eth_preproc_funnorm@colData$predictedSex
for (i in 1:length(predicted_sex)){
  if (predicted_sex[i] == "F") {predicted_sex[i] = "FEMALE"}
  else {predicted_sex[i] = "MALE"} }
predicted_sex == eth_preproc_funnorm@colData$sex
## all match
```

### Checking for the presence of SNPs inside the probe body or CpG or at the nucleotide extension
```{r}
# check presence of SNPs inside probe body or single nucleotide extensions
snps <- getSnpInfo(eth_preproc_funnorm)
str(snps@listData$Probe_rs)

eth_preproc_funnorm <- addSnpInfo(eth_preproc_funnorm)
# drop the probes that contain either a SNP at the CpG interrogation or at the single nucleotide extension
eth_preproc_funnorm_rmSNP <- dropLociWithSnps(eth_preproc_funnorm, snps=c("SBE","CpG"), maf=0)
eth_preproc_funnorm_rmSNP
```

4. Export processed data files (data.txt, and des.txt)
